<!--
SPDX-FileCopyrightText: the secureCodeBox authors

SPDX-License-Identifier: Apache-2.0
-->

# ADR-0000: Enable container autodiscovery to scan container images from private registries

<!--
  Use one of the ADR status parameter based on status
  Please add a cross reference link to the new ADR on 'superseded' ADR.
  e.g.: {adr_suposed_by} <<ADR-0000>>
-->
| <!-- -->       | <!-- --> |
|----------------|----------|
| **Status**:    | DRAFT [ADR-0013](ADR-0013.md) |
| **Date**:      | 2022-09-13 |
| **Author(s)**: | Simon HÃ¼lkenberg <simon.huelkenberg@iteratec.com> |

## Context

The SecureCodeBox offers an `autodiscovery` feature which automatically creates scheduled scans when new `services` or `containers` (in pods) are created. The container autodiscovery will start a trivy container scan for every distinct container in a given namespace. Currently it is not possible to scan container images that require `imagePullSecrets` to download the image. The container autodiscovery will create a scheduled scan but the scan itself will fail. Because of that limitation it is necessary to make the container autodiscovery aware of secrets to enable trivy to download the container images.

### Problem regarding imagePullSecretes
It is possible to configure multiple `imagePullSecrets` in a pods yaml file as seen in this [Stackoverflow](https://stackoverflow.com/questions/67073039/multiple-imagepullsecrets-in-a-kubernetes-deployment-for-the-same-url) post. Kubernetes will then try all available credentials until one succeeds. The container autodiscovery needs to do this too because trivy does not support multiple `imagePullSecrets` at once. Additionally one can only pass trivy `imagePullSecrets` as an environment variable which name depends on the location of the image (see trivy [docs](https://aquasecurity.github.io/trivy/v0.17.0/private-registries/)). For google cloud credentials one as to provide a json file path as an environment variable for [example](https://aquasecurity.github.io/trivy/v0.17.0/private-registries/gcr/). So trivy configuration changes quite significant with different platforms.  
Another problem is the fact that `imagePullSecrets` might change over time. It must be ensured that trivy has access to the newest `imagePullSecrets`.  

### Possible solutions
In general the easiest solution to provide trivy with the required credentials are kubernetes secretes that are mounted as environment variables. The following solutions use this idea although the secrets are created differently. These temporary secretes should be deleted incase the underlying scan/secret is deleted to avoid cluttering the namespace.
#### Using an initContainer and a sidecar
This option does not alter the behavior of the container autodiscovery at all. All additional logic is moved to an `initContainer` and a `sidecar` container.  
The `initContainer` reads the `imagePullSecrets` of the pod that houses the container to be scanned. The `initContainer` must determine which secret is the correct one for the scanned container image. It will then create a temporary secret following a predefined naming scheme (technically the trivy pod will be created while the secret that is mounted as an environment variable doesn't exit, thus the temporary secret name must be predefined). After the secret is created the trivy container gets executed. Simultaneously the `sidecar` will be created. It will check if the main scan container exited (similar to the lurker) and then delete the temporary secret that was used to pass the credentials to trivy to clean up after the scan to avoid cluttering of the namespace. By default a pod does not have sufficient permissions to create/delete secrets, so the pod needs to be assigned a `serviceAccount` with those permissions.   
<details><summary> Proof of concept</summary>
This simplified example will do the following: The `initContainer` will created a secret that is mounted by the main container `imagine-this-is-trivy`. The main container will print the value of the secret and then sleep for 10 seconds. When the main container completes the `sidecar` will delete the secret.   
The real implementation wouldn't use kubectl directly nor the shared volume. This is just a simplification.

```yaml
kind: ServiceAccount
metadata:
  name: internal-kubectl
---
apiVersion: v1
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: modify-secrets
rules:
- apiGroups: [""]
  resources:
  - secrets
  verbs:
  - get
  - create
  - list
  - delete
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: modify-secrets-to-service-account
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: modify-secrets
subjects:
- kind: ServiceAccount
  name: internal-kubectl
---
apiVersion: batch/v1
kind: Job
metadata:
  name: secret-test
spec:
  template:
    metadata:
      name: secret-test-pod
    spec:
      serviceAccountName: internal-kubectl
      restartPolicy: Never
      volumes:
      - name: shared-volume
        emptyDir: {}
      initContainers:
      - command:
        - sh
        - -c
        - pacman -Sy && pacman -S --noconfirm kubectl && kubectl create secret generic
          some-image-pull-secret --from-literal=username=im_a_secret!
        image: archlinux
        name: init-secret
      containers:
      - command:
        - sh
        - -c
        - echo secret is $env_test_secret && sleep 10 && touch /shared-volume/shutdown
        env:
        - name: env_test_secret
          valueFrom:
            secretKeyRef:
              key: username
              name: some-image-pull-secret
        image: archlinux
        name: imagine-this-is-trivy
        volumeMounts:
        - name: shared-volume
          mountPath: /shared-volume
      - command:
        - sh
        - -c
        - pacman -Sy && pacman -S --noconfirm kubectl && while [ ! -f /shared-volume/shutdown ]; do echo shutdownfile not found && sleep 2; done; kubectl delete secrets some-image-pull-secret
        image: archlinux
        name: secret-deletion-on-stop-sidecar
        volumeMounts:
        - name: shared-volume
          mountPath: /shared-volume
```
</details>

#### Using a separate operator
Instead of creating the temporary secret at scan runtime all secrets could be created upon creation. The operator would not listen on secrets but on pods (not every secret in a namespace is automatically used as an `imagePullSecret` so it doesn't make sense to subscribe to secrets). When a pod gets created the new operator would check if it has `imagePullSecrets` defined and if so then it would check if the specific secret was already processed. If not then it would check which `imagePullSecret` belongs to which container and then create the trivy secrets. Similar to the container autodiscovery this new operator would only create a secret for trivy for every distinct secret. When a pod gets updated the new operator will check if the `imagePullSecrets` changed. This approach will clutter the namespace quite substantially because the trivy secrets exist over continuously until the secret is not needed anymore (pod that uses the `imagePullSecrets` get deleted).